<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cpp on LMJW Blog</title><link>https://lmjw.github.io/tags/cpp/</link><description>Recent content in cpp on LMJW Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 24 Nov 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://lmjw.github.io/tags/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>Data Oriented Design</title><link>https://lmjw.github.io/post/2019-11-24-data-oriented-design/</link><pubDate>Sun, 24 Nov 2019 00:00:00 +0000</pubDate><guid>https://lmjw.github.io/post/2019-11-24-data-oriented-design/</guid><description>Data Oriented Design Check out the video. This explains the AOS and SOA very well. data orientied design
The following code is a common pattern in Object oriented programming.
struct Entity{ v3 postion, v3 velocity, int flag, virtual void update() } struct Player: public Entity{ float life, float mana, void update() override; } struct Monster: public Entity{ float life, void update() override; } sturct Door: public Entity{ bool current_status, float open_target, void update(); } There are few problems with this approach:
Memory allocation. In this objected orientied approach, because we inherited Entity objects and added some fields in child object, the size of the new Object can have different sizes.</description></item></channel></rss>